var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Fenrir","category":"page"},{"location":"#Fenrir","page":"Home","title":"Fenrir","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Fenrir exports just a single function:","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"nll","category":"page"},{"location":"#Fenrir.nll","page":"Home","title":"Fenrir.nll","text":"nll(prob::ODEProblem, data::NamedTuple{(:t, :u)}, observation_noise_var::Real,\n    diffusion_var::Real; adaptive=false, dt=false,  proj=I, order=3::Int, tstops=[])\n\nCompute the \"Fenrir\" approximate negative log-likelihood (NLL) of the data.\n\nThis is a convenience function that\n\nSolves the ODE with a ProbNumDiffEq.EK1 of the specified order and with a diffusion as provided by the diffusion_var argument, and\nFits the ODE posterior to the data via Kalman filtering and thereby computes the negative log-likelihood on the way.\n\nBy default, the solver steps exactly through the time points data.t. In addition, you can provide a step size with dt or time stops with tstops. Or, set adaptive=true for adaptive step-size selection - use at your own risk!\n\nReturns a tuple (nll::Real, times::Vector{Real}, states::StructVector{Gaussian}), where states contains the filtering posterior. Its mean and covariance can be accessed with states.μ and states.Σ.\n\nArguments\n\nprob::ODEProblem: the initial value problem of interest\ndata::NamedTyple{{(:t, :u)}}: the data to be fitted\nobservation_noise_var::Real: the scalar observation noise variance\ndiffusion_var: the diffusion parameter for the integrated Wiener process prior; this plays a similar role as kernel hyperparamers in Gaussian-process regression\ndt=false: step size parameter, passed to OrdinaryDiffEq.init\nadaptive=false: flag to determine if adaptive step size selection should be used; use at your own risk!\ntstops=[]: additional time stops the algorithm should step through; passed to OrdinaryDiffEq.solve\norder::Int=3: the order of the ProbNumDiffEq.EK1 solver\nproj=I: the matrix which maps the ODE state to the measurements; typically a projection\n\n\n\n\n\n","category":"function"}]
}
